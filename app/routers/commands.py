from fastapi import APIRouter, Request, Response, status, HTTPException
from fastapi import Depends
from slowapi.errors import RateLimitExceeded
from slowapi import Limiter
from ..schemas import Query, ExecuteRequest, CommandResponse
from ..llm_service import get_command_from_llm, is_safe_kubectl_command
from ..utils import execute_command_async, sanitize_query
from ..auth import verify_api_key
from ..config import limiter, cache, logger, EXECUTION_TIMEOUT
import datetime

router = APIRouter()

@router.post("/kubectl-command",
             response_model=CommandResponse,
             dependencies=[Depends(verify_api_key)],
             summary="Generate and optionally execute a kubectl command from natural language",
             responses={
                 200: {"description": "Command generated (and optionally executed)"},
                 400: {"description": "Invalid input query"},
                 401: {"description": "Unauthorized (Missing or invalid API Key)"},
                 422: {"description": "Unsafe command generated by LLM"},
                 429: {"description": "Rate limit exceeded"},
                 500: {"description": "Internal server error"},
                 503: {"description": "Service unavailable (LLM or execution issue)"},
                 504: {"description": "Gateway timeout (LLM or execution)"}
             })
@limiter.limit("10/minute")
async def get_kubectl_command(
    q: Query,
    request: Request,
    response: Response
):
    logger.info(f"Received query: '{q.query}'")
    sanitized_query = sanitize_query(q.query)

    from_cache = False
    command = None
    try:
        cached_command = cache.get(sanitized_query)
        if cached_command is not None:
            logger.info(f"Cache hit for query: {sanitized_query}")
            command = cached_command
            from_cache = True
        else:
            logger.info(f"Cache miss for query: {sanitized_query}")
            command = await get_command_from_llm(sanitized_query)
            cache[sanitized_query] = command
            logger.debug(f"Stored result in cache for query: {sanitized_query}")

    except HTTPException as http_exc:
        raise http_exc
    except Exception as e:
        logger.exception(f"Unexpected error processing query '{sanitized_query}': {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Internal server error processing request"
        )

    execution_data = {"metadata": {
        "start_time": datetime.datetime.utcnow().isoformat(),
        "end_time": datetime.datetime.utcnow().isoformat(),
        "duration_ms": 0.0,
        "success": True
    }}

    return CommandResponse(
        kubectl_command=command,
        execution_result=execution_data.get("execution_result"),
        execution_error=execution_data.get("execution_error"),
        from_cache=from_cache,
        metadata=execution_data["metadata"]
    )

@router.post("/execute",
             response_model=CommandResponse,
             dependencies=[Depends(verify_api_key)],
             summary="Execute a kubectl command",
             responses={
                 200: {"description": "Command executed successfully"},
                 400: {"description": "Invalid command"},
                 401: {"description": "Unauthorized (Missing or invalid API Key)"},
                 429: {"description": "Rate limit exceeded"},
                 500: {"description": "Internal server error"},
                 504: {"description": "Gateway timeout (execution)"}
             })
@limiter.limit("10/minute")
async def execute_kubectl_command(
    req: ExecuteRequest,
    request: Request,
    response: Response
):
    logger.info(f"Received execute request for command: '{req.execute}'")
    
    if not is_safe_kubectl_command(req.execute):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Command failed safety checks"
        )
    
    execution_data = await execute_command_async(req.execute, EXECUTION_TIMEOUT)
    
    return CommandResponse(
        kubectl_command=req.execute,
        execution_result=execution_data.get("execution_result"),
        execution_error=execution_data.get("execution_error"),
        from_cache=False,
        metadata=execution_data["metadata"]
    )